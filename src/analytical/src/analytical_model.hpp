///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  File name: analytical_model.hpp
//  Description: Analytical NoC performance model for fast latency estimation
//  Created by:  Claude Code
//  Date:  15/09/2025
//
/////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _ANALYTICAL_MODEL_HPP_
#define _ANALYTICAL_MODEL_HPP_

#include <vector>
#include <map>
#include <set>
#include <deque>
#include <tuple>
#include <string>
#include <iostream>
#include <fstream>

#include "../include/nlohmann/json.hpp"

// Forward declarations
class AnalyticalLogger;

// Communication types matching restart/BookSim2 protocol
enum commType {
    READ_REQ = 1,   // Read request from PE to memory
    READ_ACK = 3,   // Read acknowledgment from memory to PE
    READ = 5,       // Read data transfer from memory to PE
    WRITE_REQ = 2,  // Write request from PE to memory
    WRITE_ACK = 4,  // Write acknowledgment from memory to PE
    WRITE = 6,      // Write data transfer from PE to memory
    ANY = 0         // Any packet type (used for generic handling)
};

// Helper functions for commType
commType intToCommType(int i);
std::string commTypeToString(commType type);
bool isRequestType(commType type);
bool isReplyType(commType type);

// Configuration structure to hold architectural parameters
struct ArchConfig {
    // Network topology
    std::string topology;
    int k;  // network radix
    int n;  // network dimensions

    // Timing parameters
    int output_delay;
    int credit_delay;
    int speculative;
    int routing_delay;
    int vc_alloc_delay;
    int sw_alloc_delay;
    int st_prepare_delay;
    int st_final_delay;
    int flit_size;  // in bits

    // Flow control
    int num_vcs;
    int vc_buf_size;
    float ANY_comp_cycles; // Processing cycles for ANY type packets
    int threshold_pe_mem;  // Threshold to distinguish PE vs Memory nodes

    // Defaults
    ArchConfig() : topology("torus"), k(4), n(2),
                   routing_delay(1), vc_alloc_delay(1), sw_alloc_delay(1),
                   st_prepare_delay(0), st_final_delay(1), flit_size(64),
                   num_vcs(16), vc_buf_size(8), ANY_comp_cycles(1.0), threshold_pe_mem(1024) {}
};

// Packet structure (simplified from restart version)
struct AnalyticalPacket {
    int id;
    int src;
    int dst;
    int size;  // in bytes
    std::vector<int> dep;  // dependencies
    commType type;  // packet type (READ_REQ, WRITE_REQ, etc.)
    int pt_required;  // processing time required
    int data_size;      // size of data to be transferred (for generated packets)
    int data_dep;       // data dependency ID

    // Additional fields for handshake protocol
    int bulk_data; // bulk size in Bytes which will be converted to flits and added to handshake protocol
    int bulk_pt_required; // processing time in cycles for handshake protocol

    // Computed fields
    int size_flits;   // size in flits after conversion
    double injection_time;
    double completion_time;
    bool auto_generated;  // true if packet was auto-generated by handshake

    AnalyticalPacket() : id(-1), src(-1), dst(-1), size(0), type(ANY),
                        pt_required(0), data_size(0),
                        data_dep(-1), size_flits(0), injection_time(0.0),
                        completion_time(0.0), auto_generated(false) {}
};

// Workload structure (simplified)
struct AnalyticalWorkload {
    int id;
    int pe;  // processing element
    std::vector<int> dep;
    int size;  // in bytes
    int cycles_required;

    AnalyticalWorkload() : id(-1), pe(-1), size(0), cycles_required(0) {}
};

// Logger for tracking events and results
class AnalyticalLogger {
public:
    struct Event {
        double time;
        std::string type;
        int packet_id;
        int node;
        std::string description;
    };

    std::vector<Event> events;

    void log_event(double time, const std::string& type, int packet_id,
                   int node, const std::string& description);
    void print_events(std::ostream& out) const;
    void clear();
};

// Main analytical model class
class AnalyticalModel {
private:
    // Configuration
    ArchConfig _arch;
    std::vector<AnalyticalPacket> _packets;
    std::vector<AnalyticalWorkload> _workloads;
    std::vector<AnalyticalPacket> _generated_packets;  // For dynamically generated packets

    // Dependency tracking
    std::vector<std::set<std::tuple<int, int, double>>> _executed;  // (id, type, completion_time)
    std::vector<std::deque<const AnalyticalPacket*>> _waiting_packets;  // per node
    std::vector<std::deque<const AnalyticalWorkload*>> _waiting_workloads;  // per node
    std::vector<const AnalyticalWorkload*> _pending_workloads;  // being processed

    // Simulation state
    double _current_time;
    int _nodes;
    AnalyticalLogger* _logger;
    std::ostream* _output_file;
    size_t _last_generated_processed;

    // Processing element timers
    std::vector<double> _npu_free_time;  // when each NPU becomes free

    // Reply packet completion times
    std::vector<double> _pending_reply_completions;  // completion times of in-flight reply packets

    // Debug flag
    bool _debug_output;  // enable/disable verbose debug output

    // Event-driven reordering optimization
    std::vector<bool> _node_needs_packet_reorder;   // Track which nodes need packet queue reordering
    std::vector<bool> _node_needs_workload_reorder; // Track which nodes need workload queue reordering

public:
    AnalyticalModel();
    ~AnalyticalModel();

    // Configuration
    void configure(const std::string& config_file);
    void set_output_file(std::ostream* out) { _output_file = out; }
    void set_logger(AnalyticalLogger* logger) { _logger = logger; }

    // Topology calculations
    int calculate_hop_distance(int src, int dst) const;

    // Latency calculations
    double calculate_message_latency(int src, int dst, int size_flits) const;
    int calculate_num_flits(int size_bytes) const;

    // Dependency management
    bool check_dependencies_satisfied(const AnalyticalPacket* packet, int node) const;
    bool check_dependencies_satisfied(const AnalyticalWorkload* workload, int node) const;
    double get_dependency_completion_time(const std::vector<int>& deps, int node) const;

    // Simulation execution
    long long run_simulation();
    void process_packets();
    void process_workloads();
    void inject_ready_packets();
    void process_generated_packets();
    void advance_time();

    // Queue management optimizations (BookSim2-style)
    void reorder_packet_queue(int node);
    void reorder_workload_queue(int node);

    // Event-driven reordering triggers
    void mark_workload_event(int node);          // Workload start/end
    void mark_packet_injection_event(int node);  // WRITE/WRITE_REQ injection

    // Handshake protocol methods
    void generate_handshake_packets(const AnalyticalPacket* received_packet, double arrival_time);
    void generate_reply_packet(const AnalyticalPacket* request_packet, double reply_time);
    commType get_reply_type(commType request_type);

    // Results and statistics
    double get_simulation_time() const { return _current_time; }
    int get_total_packets() const { return _packets.size(); }
    AnalyticalLogger* get_logger() const { return _logger; }

    // Utility functions
    void preprocess_packets();  // Convert bytes to flits
    void print_statistics(std::ostream& out, double final_time = -1) const;

private:
    // Helper functions
    bool check_dependencies_helper(const std::vector<int>& deps, int node) const;
};

#endif // _ANALYTICAL_MODEL_HPP_